<!doctype html><html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Python</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles2.css" type="text/css" />
</head>
<body><h1><b><u>Python</u></b></h1>We can inject a + (properly encoded) and another double-quote to get a response without error.<br /><br />Now, we need to make sure it's a Python application, we can for example use: <br /> "%2bstr(True)%2b"test. The fact that both str() and True  are available give us a pretty good chance that Python is used. For the  rest of the challenge we will put our payload inside of the call to str().<br /><br />Now, we want to get to code execution. We can try to use os.system('id') for example. <br />We can see a 0 coming back in the response. This shows that the command got executed successfully. If you try an invalid command like hacker, you will get 32512 meaning that the process returned 127 (since the command is not found).<br /><br />It may also be valuable to get the value returned by the command. To do this, you can use: os.popen('[CMD]').read() instead of os.system('[CMD]'). <br /><br />If we try to use os.system('id') for example. we get an error message. This is likely due to the fact that the os module (that we need to access system) is not loaded. We can use the following syntax to load and run the system function: __import__('os').system(..<br /><br /><br />Character filter:<br />To bypass this issue, we can use base64 encoding. We will send a base64 encoded command to the server (to avoid the / in the path) and tell the server to decode it using the function b64decode. The call to b64decode will be done by the server as part of our payload.  Unfortunately the base64 module is not loaded, so we will need to use the __import__ trick to load base64.<br /></body></html>